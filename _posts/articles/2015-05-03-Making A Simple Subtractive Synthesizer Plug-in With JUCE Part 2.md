---
layout: page
title: Making A Simple Subtractive Synthesizer Plugin With JUCE - Part 2
excerpt: "Creating a simple volume knob"
categories: articles
tags: [sample-post, code, highlighting]
modified: 2013-05-04
comments: true
share: true
---

Last time we installed all the packages and did some initial setup so that we can start writing our code. In this tutorial we're going to familiarize ourselves with JUCE's workflow and create a simple VST volume knob.  

# The source folder 

Click on the <strong>Files</strong> tab next to the <strong>Config</strong> tab. You will see the source folder, which is the folder that contains all your code. For the case of audio plugins, JUCE automatically creates four files for you. The <strong>PluginProcessor</strong> files (.cpp and .h) mainly contains code that handles the audio processing of the VST, e.g. midi input output and signal processing. The other two files -- <strong>PluginEditor</strong>.cpp and .h -- is code mainly for the graphical user interface (GUI). These aren't really strict rules, but merely provides a framework you can build your application on top of. In this turotial, I'll stick to this general framework, but if you're a more advanced coder, feel free to change things around as you see fit.

Several things happens when the user changes the volume knob, which I'll illustrate in the picture below (Figure 2.1).

<figure>
<image src="/images/flow_volumeknob.png" alt="image">
</image>
</figure>

Not too complicated right? Let's look at each piece individually.

# Step 1: Drawing the knob

To create the knob, there's two things we can do. The first option is to use the provided JUCE GUI editor. The GUI editor gives the user a visual platform to create and modify the components of your VST. JUCE will then automatically generate the code for you. This is not the option we're going to take. We're actually going to take the second option, which is to code everything ourselves, by hand. Why? Because I think programming the volume knob is a fairly easy thing to conceptualize and program, therefore it's a good way to gain a better understanding how our code translates into visual objects. 

Okay, without further ado, let's create our volume knob. If you go to the <strong>PluginEditor.cpp</strong> file, you should see the following auto-generated code.

{% highlight C++ %}
/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin editor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
AsdfAudioProcessorEditor::AsdfAudioProcessorEditor (AsdfAudioProcessor& p)
    : AudioProcessorEditor (&p), processor (p)
{
    // Make sure that before the constructor has finished, you've set the
    // editor's size to whatever you need it to be.
    setSize (400, 300);
}

AsdfAudioProcessorEditor::~AsdfAudioProcessorEditor()
{
}

//==============================================================================
void AsdfAudioProcessorEditor::paint (Graphics& g)
{
    g.fillAll (Colours::white);

    g.setColour (Colours::black);
    g.setFont (15.0f);
    g.drawFittedText ("Hello World!", getLocalBounds(), Justification::centred, 1);
}

void AsdfAudioProcessorEditor::resized()
{
    // This is generally where you'll want to lay out the positions of any
    // subcomponents in your editor..
}

{% endhighlight %}
{% highlight css %}
{% endhighlight %}

If you're fairly new to programming, this is probably pretty intimidating. But the truth is, a lot of the code can be understood by deconstructing it into several key concepts. 
<p>
<strong>!!! Warning, a somewhat long explanation of C++ concepts !!! </strong>
</p>

#### Classes 

First is the concept of <strong>classes</strong>. Classes are an intermediate topic, most likely something you'll learn towards the end of an intro to C++ course. This means that I'm skipping a bunch of fundamental concepts that you would otherwise learn in a normal C++ course. The main problem with fundamentals, although VERY important, is that it tends to be dry and boring. If you're a producer or musician, it's likely that you probably don't care much to taking the traditional approach of memorizing the differences between a for loop and a while loop. Thus, I'm going to try and take a "learn as you go" approach. This way, you can always go back and learn the fundamentals on your own. I always find that the boring stuff is WAY easier to learn when you have some context. 

According to [Wikipedia](http://en.wikipedia.org/wiki/C%2B%2B_classes): 

<blockquote>
A class is a user defined type or data structure declared with keyword class that has data and functions (also called methods) as its members whose access is governed by the three access specifiers private, protected or public (by default access to members of a class is private). 
</blockquote>

Okay, the definition through out a bunch of words at us. Let's just focus on these: <strong>a class has data and functions (also called methods) as its members.</strong> To make things even easier, I'm going to use a metaphor to illustrate these concepts. Say we have a dog (Figure 2.2). If we were to deconstruct the characteristics of a dog, what would it be like? Well, unless you have some kind of mutant dog, it typically has 2 eyes, 1 nose, 1 mouth, 1 tail, some kind of coat (fur) etc. Dogs also exhibit certain behaviors that  make them distinctly "dog-like," such as barking, knowing how to sit on command, and eating. If your dog can fly, or has mastered differential calculus, well you may have something else in your presence. 

<figure>
<image src="/images/class_dog.png" alt="image">
</image>
<caption>
Figure 2.2: Class dog 
</caption>
</figure>

If we abstract out these attributes and behaviors that characterizes a dog into code, we get something like what we see contained in the bubble on the right (Figure 2.2). I'll rewrite the code a little cleaner in Figure 2.3. Now, we have the variables (data) and functions (methods) that we need to describe the dog. The variables should be straightforward to understand. We declare that eyes is equal to 2, whereas nose is equal to 1. The semicolon at the end of each declaration is important to C++ and is called a <strong>punctuator</strong>. Make sure to include them when you're declaring variables. The <strong>int</strong> in front of each variable specifies the <strong>type</strong> of the variable. Int as you may have guessed, is short for <strong>integer</strong>. There are multiple fundamental data types in C++ (as in many other languages). You don't need to master them all now, just know that they exist and that they are important. 

<figure>
{% highlight C++ %}

#variables (data)
int eyes = 2;
int nose = 1;
int mouth = 1;

#functions (methods)
float eatFood (float food)
{
    float poop;
    poop = food/2.0;
    return poop;
}
{% endhighlight %}
{% highlight css %}
{% endhighlight %}
<caption>
Figure 2.3: holy god!
</caption>
</figure>

#### Functions 

Functions may be a little harder to grasp if you have little coding experience. To put it briefly, a function takes something in, does something to whatever it takes in, and spits something out. Shift your attention to Figure X. I've drawn out the "eatFood" function that I showed you in Figure X. There are three components to a function: the function declaration, function body, and function output. The function declaration is kind of like the summary of the function's purpose. For function eatFood, the function declaration is <strong>float eatFood (float food)</strong>. It consists of <strong>eatFood</strong> -- name of our function -- <strong>(float food)</strong> -- the input type and name the function takes in -- and the <strong>return type</strong> -- float. 

<figure>
<image src ="/images/dog_functions.png" alt="image">
</image>
</figure>

The function body is where it does something to the input. In the function body, we declare a <strong>float</strong> (another data type that handles numbers with decimals) called poop. We set the poop equal to food/2.0, which is equivalent to saying 12.0 divided by 6.0, since in the drawing food is equal to 12.0 (I chose 12.0 for the sake of illustration, but food can really be any value that is a float). We then, specify our return value as poop (our function <strong>output</strong>). Recall that we declared the function return type to be <strong>float</strong> so the return value of poop must be a float. There are cases where the function doesn't return anything specifically, in which case we would say <strong>void</strong> instead of float in the function declaration. Also, don't forget to put semicolons at the end of each line and to bracket the function body if you don't want errors!
<p></p>

Okay, that was a lot. But we're actually pretty close to constructing a real class. We're just missing a couple things. First, we have to declare that it actually is a class called <em>dog</em> by bracketing (note the semicolon at the end) and declaring <strong>class dog</strong>. Next, we are going to provide some <strong>Access Specifiers</strong>. These are actually not required, but it's good to provide them anyways. Anything specified as <strong>private</strong> means that only the dog class has access to these variables/functions. Anything that is <strong>public</strong> can be accessed by everybody. By default, all classes in C++ are <strong>private</strong> so remember that. Finally, we need to specify that the "eatFood" function belongs to the dog class. We do this by including the "<strong>::</strong>" operator, known as the <strong>scope resolution operator</strong> preceded by the class name "dog" in the function declaration. 

<figure>
{% highlight C++ %}

class dog
{
public: 
    //variables (data)
    int eyes = 2;
    int nose = 1;
    int mouth = 1;
    float eatFood(float food);
};

// functions (methods)
float dog::eatFood (float food)
{
    float poop;
    poop = food/2.0;
    return poop;
}
{% endhighlight %}
{% highlight css %}
{% endhighlight %}
<caption>
Figure 2.3: Code for class dog.
</caption>
</figure>

And there you go, you've got a class! Let's go back to <strong>PluginEditor.cpp</strong> and see if we can understand it now. Take a look at the following code snipped from PluginEditor.cpp. Do you recognize anything? The first line says <strong>void AsdfAudioProcessorEditor::paint (Graphics& g)</strong>. If we compare this with the function <strong>float dog::eatFood (float food)</strong> from the dog class, we notice that syntatically they're very similar. Why? Because void AsdfAudioProcessorEditor::paint (Graphics& g) is a function called "paint" of class "AsdfAudioProcessorEditor." It has no specific return type so it has a void preceding the class definition and the function takes in something called "Graphics& g." It also has a function body with a several things in it. More on that later. 

{% highlight C++ %}

void AsdfAudioProcessorEditor::paint (Graphics& g)
{
    g.fillAll (Colours::white);

    g.setColour (Colours::black);
    g.setFont (15.0f);
    g.drawFittedText ("Hello World!", getLocalBounds(), Justification::centred, 1);
}

{% endhighlight %}
{% highlight css %}
{% endhighlight %}

I hear some of you saying, "hey wait, where is the class declaration?" In the dog class, we had the words "class dog," but here it is no where to be seen. 

#### Cpp and h Files 

It turns out that the introjucer has split up the class into two files, so the actual class declaration is contained in <strong>PluginEditor.h</strong> (Figure XX). Here you will see the familiar access specifiers, the class methods, and variables. 

{% highlight C++ %}

#ifndef PLUGINEDITOR_H_INCLUDED
#define PLUGINEDITOR_H_INCLUDED

#include "../JuceLibraryCode/JuceHeader.h"
#include "PluginProcessor.h"

class AsdfAudioProcessorEditor : public AudioProcessorEditor
{
public:
    AsdfAudioProcessorEditor (AsdfAudioProcessor&);
    ~AsdfAudioProcessorEditor();

    //==============================================================================
    void paint (Graphics&) override;
    void resized() override;

private:
    // This reference is provided as a quick way for your editor to
    // access the processor object that created it.
    AsdfAudioProcessor& processor;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AsdfAudioProcessorEditor)
};

#endif  // PLUGINEDITOR_H_INCLUDED

{% endhighlight %}
{% highlight css %}
{% endhighlight %}

It is common practice to separate the cpp and header files, which I illustrate in Figure (XW). Why? For this tutorial, you don't really need to know the gory details (for more detail you can check out for e.g. [here](http://stackoverflow.com/questions/333889/why-have-header-files-and-cpp-files-in-c)). What you <em>do</em> need to know is that whenever you split something into a .h and .cpp file, they need to "talk" to each other. You do this by putting <strong>#include header_name.h</strong> at the top of the .cpp file, as you can see in PluginEditor.cpp. This way, the compiler remembers to copy and paste content of the .h file into .cpp during compilation. It is also a good rule of thumb to write the function declarations in the .cpp files, while you declare variables and functions in the header file. 
<figure>
<image src="/images/dog_cppandh.png" alt="images">
</image>
</figure>

#### Inheritance 

One, last, thing. We have to talk about inheritance. Not the kind of inheritance where you get money from your deceased grandfather so that you can screw around and travel the world, but <strong>class inheritance</strong>. By using the concept of inheritance we can create completely new classes (derived classes), while still retainig the characteristics of the original class (base class). For instance, imagine that we have a base class called "class dog." We can derive new classes such as "green dog," "small lavender dog," and "Clifford" simply by inheriting fro the base dog class. Each derived class will have features that are common to the derived class e.g. have 2 eyes, 1 nose, 1 tail etc.   

<figure>
<image src="/images/dog_inheritance.png" alt="images">
</image>
</figure>

In C++ syntax, we write it in the following way. Our new class "AsdfAudioProcessorEditor" is inheriting from the AudioProcessorEditor class. 

{% highlight C++ %}

class AsdfAudioProcessorEditor : public AudioProcessorEditor

{% endhighlight %}
{% highlight css %}
{% endhighlight %}

Holy hell we're done for this part! Take a break by listening to some [Star Guitar by the Chemical Bros.](https://www.youtube.com/watch?v=0S43IwBF0uM)

We now have the tools to start writing our volume knob (hey, no one said it was easy).